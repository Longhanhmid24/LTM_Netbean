<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>üí¨ Chat Realtime (G·ª≠i file + Ti·∫øn tr√¨nh upload)</title>

  <!-- SockJS + STOMP -->
  <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

  <style>
    body { 
      font-family: Arial, sans-serif; 
      background: #f9f9f9; 
      padding: 20px;
    }

    h2 {
      color: #333;
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }

    h2::before {
      content: "üí¨";
      margin-right: 10px;
    }

    #chat-box {
      height: 380px;
      border: 1px solid #ddd;
      background: #fff;
      overflow-y: auto;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .msg-wrapper {
      display: flex;
      margin-bottom: 10px;
      clear: both;
    }

    .msg {
      padding: 10px 14px;
      border-radius: 15px;
      max-width: 70%;
      word-wrap: break-word;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .me-wrapper { justify-content: flex-end; }
    .me {
      background: #007bff;
      color: #fff;
      border-bottom-right-radius: 2px;
    }

    .other-wrapper { justify-content: flex-start; }
    .other {
      background: #f1f0f0;
      color: #000;
      border-bottom-left-radius: 2px;
    }

    #controls {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-top: 10px;
    }

    input[type="text"] {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }

    input[type="file"] { display: none; }

    label {
      background: #17a2b8;
      color: white;
      padding: 9px 15px;
      border-radius: 8px;
      cursor: pointer;
    }

    button {
      background: #007bff;
      color: white;
      padding: 9px 15px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    button:hover, label:hover {
      opacity: 0.9;
    }

    #progress-container {
      width: 100%;
      background: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 10px;
      display: none;
      height: 12px;
    }

    #progress-bar {
      height: 12px;
      width: 0%;
      background: #007bff;
      transition: width 0.3s;
    }

    #progress-text {
      text-align: right;
      font-size: 13px;
      color: #333;
      margin-top: 3px;
    }

    /* Video Call UI */
    #call-controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }
    #video-container {
      display: none;
      justify-content: space-around;
      margin-top: 15px;
    }
    video {
      width: 45%;
      border-radius: 10px;
      background: #000;
    }
  </style>
</head>
<body>
  <h2>Chat Realtime (c√≥ g·ª≠i file & ti·∫øn tr√¨nh upload)</h2>

  <div id="chat-box"></div>

  <div id="controls">
    <input id="message" type="text" placeholder="Nh·∫≠p tin nh·∫Øn..." onkeypress="if(event.key==='Enter') sendMessage()" />
    <label for="fileInput">üìé File</label>
    <input id="fileInput" type="file" onchange="uploadFile(event)" />
    <button onclick="sendMessage()">G·ª≠i</button>
  </div>

  <div id="progress-container">
    <div id="progress-bar"></div>
  </div>
  <div id="progress-text"></div>

  <!-- === VIDEO CALL SECTION === -->
  <div id="call-controls">
    <button onclick="startCall('audio')">üîä G·ªçi tho·∫°i</button>
    <button onclick="startCall('video')">üé• G·ªçi video</button>
    <button onclick="hangUp()">‚ùå K·∫øt th√∫c</button>
  </div>

  <div id="video-container">
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>
  </div>

<script>
  let stompClient = null;
  const serverIp = window.location.hostname || "localhost";
  const protocol = window.location.protocol === "https:" ? "https" : "http";

  const userId = Number(prompt("Nh·∫≠p ID c·ªßa b·∫°n (1 ho·∫∑c 2):"));
  const receiverId = userId === 1 ? 2 : 1;

  // ‚úÖ K·∫øt n·ªëi WebSocket chat
  function connect() {
    const socket = new SockJS(`${protocol}://${serverIp}:8080/ws`);
    stompClient = Stomp.over(socket);

    stompClient.connect({}, (frame) => {
      console.log("‚úÖ Connected:", frame);

      stompClient.subscribe(`/queue/messages/${userId}`, (message) => {
        const msg = JSON.parse(message.body);
        appendMessage(msg.senderId === userId ? "me" : "other", msg);
      });
    });
  }

  // ‚úÖ G·ª≠i tin nh·∫Øn text
  function sendMessage() {
    const content = document.getElementById("message").value.trim();
    if (!content) return;

    const msg = {
      senderId: userId,
      receiverId: receiverId,
      content: content,
      messageType: "text"
    };

    stompClient.send("/app/chat.send", {}, JSON.stringify(msg));
    appendMessage("me", msg);
    document.getElementById("message").value = "";
  }

  // ‚úÖ Upload file (·∫£nh / video / t√†i li·ªáu)
  async function uploadFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append("file", file);

    const progressBar = document.getElementById("progress-bar");
    const progressContainer = document.getElementById("progress-container");
    const progressText = document.getElementById("progress-text");
    progressContainer.style.display = "block";

    try {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", `${protocol}://${serverIp}:8080/api/upload`, true);

      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          progressBar.style.width = percent + "%";
          progressText.textContent = `ƒêang t·∫£i l√™n: ${percent}%`;
        }
      };

      xhr.onload = () => {
        progressContainer.style.display = "none";
        progressBar.style.width = "0%";
        progressText.textContent = "";

        if (xhr.status === 200) {
          const res = JSON.parse(xhr.responseText);
          console.log("üìÅ Upload th√†nh c√¥ng:", res);

          let fileType = res.fileType;
          if (!fileType || fileType === "undefined") {
            const mime = file.type;
            if (mime.startsWith("image/")) fileType = "image";
            else if (mime.startsWith("video/")) fileType = "video";
            else fileType = "file";
          }

          const msg = {
            senderId: userId,
            receiverId: receiverId,
            messageType: fileType,
            mediaUrl: res.url,
            fileName: res.fileName,
            contentType: res.contentType
          };

          stompClient.send("/app/chat.send", {}, JSON.stringify(msg));
          appendMessage("me", msg);
        } else {
          console.error("‚ùå Upload th·∫•t b·∫°i:", xhr.responseText);
          alert("‚ùå L·ªói upload file!");
        }
      };

      xhr.onerror = () => {
        progressContainer.style.display = "none";
        progressBar.style.width = "0%";
        progressText.textContent = "";
        console.error("‚ùå Upload l·ªói:", xhr.responseText);
        alert("‚ùå Kh√¥ng th·ªÉ upload file!");
      };

      xhr.send(formData);
    } catch (err) {
      progressContainer.style.display = "none";
      progressBar.style.width = "0%";
      progressText.textContent = "";
      console.error("L·ªói upload:", err);
      alert("‚ùå Upload th·∫•t b·∫°i!");
    }
  }

  // ‚úÖ Hi·ªÉn th·ªã tin nh·∫Øn
  function appendMessage(type, msg) {
    const chatBox = document.getElementById("chat-box");
    const wrapper = document.createElement("div");
    wrapper.classList.add("msg-wrapper", type === "me" ? "me-wrapper" : "other-wrapper");

    const msgDiv = document.createElement("div");
    msgDiv.classList.add("msg", type);

    if (msg.messageType === "text") {
      msgDiv.textContent = msg.content;
    } else if (msg.messageType === "image") {
      msgDiv.innerHTML = `<img src="${msg.mediaUrl}" style="width:230px; border-radius:10px; max-width:100%;">`;
    } else if (msg.messageType === "video") {
      msgDiv.innerHTML = msg.contentType
        ? `<video controls width="250" style="border-radius:10px;"><source src="${msg.mediaUrl}" type="${msg.contentType}"></video>`
        : `<video controls width="250" style="border-radius:10px;"><source src="${msg.mediaUrl}"></video>`;
    } else {
      msgDiv.innerHTML = `
        <a href="${msg.mediaUrl}" target="_blank"
           style="
             display:inline-block;
             text-decoration:none;
             font-weight:500;
             color:${type === "me" ? "#fff" : "#007bff"};
             background:${type === "me" ? "#0056b3" : "#e9ecef"};
             padding:8px 14px;
             border-radius:8px;
             box-shadow:0 1px 3px rgba(0,0,0,0.1);
           ">
           üìé ${msg.fileName}
        </a>`;
    }

    wrapper.appendChild(msgDiv);
    chatBox.appendChild(wrapper);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // ‚úÖ T·∫£i l·ªãch s·ª≠ tin nh·∫Øn
  async function loadOldMessages() {
    try {
      const res = await fetch(`${protocol}://${serverIp}:8080/api/messages/${userId}/${receiverId}`);
      if (!res.ok) return;
      const messages = await res.json();

      messages.forEach(m => {
        appendMessage(
          m.sender_id === userId ? "me" : "other",
          {
            senderId: m.sender_id,
            receiverId: m.receiver_id,
            content: m.content,
            messageType: m.message_type,
            mediaUrl: m.media_url,
            fileName: m.file_name
          }
        );
      });
    } catch (e) {
      console.warn("‚ö†Ô∏è Kh√¥ng t·∫£i ƒë∆∞·ª£c l·ªãch s·ª≠ tin nh·∫Øn:", e);
    }
  }

  // === WebRTC CALL ===
  let stompCall = null;
  let pc = null;
  let localStream = null;

  function connectCall() {
    const socket = new SockJS(`${protocol}://${serverIp}:8080/ws/call`);
    stompCall = Stomp.over(socket);

    stompCall.connect({}, () => {
      stompCall.subscribe(`/queue/call/${userId}`, async (frame) => {
        const signal = JSON.parse(frame.body);
        console.log("üì° Nh·∫≠n t√≠n hi·ªáu:", signal);

        if (signal.type === "offer") {
          await initWebRTC(signal.callType);
          await pc.setRemoteDescription({ type: "offer", sdp: signal.sdp });
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal({ type: "answer", sdp: answer.sdp });
        } else if (signal.type === "answer") {
          await pc.setRemoteDescription({ type: "answer", sdp: signal.sdp });
        } else if (signal.type === "candidate") {
          pc.addIceCandidate(JSON.parse(signal.candidate));
        } else if (signal.type === "hangup") {
          endCall();
        }
      });
    });
  }

  async function initWebRTC(callType) {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert("‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ truy c·∫≠p camera/mic. H√£y ch·∫°y qua HTTP(S) server!");
      throw new Error("MediaDevices not supported");
    }

    pc = new RTCPeerConnection();
    pc.onicecandidate = (e) => {
      if (e.candidate) sendSignal({ type: "candidate", candidate: JSON.stringify(e.candidate) });
    };
    pc.ontrack = (e) => {
      document.getElementById("remoteVideo").srcObject = e.streams[0];
    };

    localStream = await navigator.mediaDevices.getUserMedia(
      callType === "video" ? { video: true, audio: true } : { audio: true }
    );
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    document.getElementById("localVideo").srcObject = localStream;
    document.getElementById("video-container").style.display = "flex";
  }

  async function startCall(callType) {
    await initWebRTC(callType);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    sendSignal({ type: "offer", sdp: offer.sdp, callType });
  }

  function sendSignal(data) {
    stompCall.send("/app/call.send", {}, JSON.stringify({
      callerId: userId,
      receiverId,
      ...data
    }));
  }

  function hangUp() {
    sendSignal({ type: "hangup" });
    endCall();
  }

  function endCall() {
    if (localStream) localStream.getTracks().forEach(t => t.stop());
    if (pc) pc.close();
    document.getElementById("video-container").style.display = "none";
  }

  connect();
  loadOldMessages();
  connectCall();
</script>
</body>
</html>
